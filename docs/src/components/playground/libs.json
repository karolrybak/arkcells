{
  "arktype/index.ts": "export { ArkError, ArkErrors, Traversal, TraversalError, type ArkSchemaConfig, type ArkSchemaScopeConfig, type JsonSchema } from \"@ark/schema\";\nexport { Hkt, inferred, ParseError } from \"@ark/util\";\nexport { regex } from \"arkregex\";\nexport type { distill, Out } from \"./attributes.ts\";\nexport * from \"./config.ts\";\nexport { Generic } from \"./generic.ts\";\nexport { ark, declare, define, fn, generic, keywords, match, type, type Ark } from \"./keywords/keywords.ts\";\nexport { Module, type BoundModule, type Submodule } from \"./module.ts\";\nexport type { inferDefinition, validateDefinition } from \"./parser/definition.ts\";\nexport { scope, type bindThis, type Scope } from \"./scope.ts\";\nexport { Type } from \"./type.ts\";\nexport type { BaseType } from \"./variants/base.ts\";\n",
  "arktype/type.ts": "import { ArkErrors, BaseRoot, type BaseParseOptions, type Morph, type NodeSelector, type Predicate, type RootSchema, type TypeMeta } from \"@ark/schema\";\nimport { Callable, Hkt, type Constructor, type array, type conform } from \"@ark/util\";\nimport type { distill } from \"./attributes.ts\";\nimport type { DeclarationParser } from \"./declare.ts\";\nimport type { FnParser } from \"./fn.ts\";\nimport type { Generic, GenericParser, ParameterString, baseGenericConstraints, parseValidGenericParams, validateParameterString } from \"./generic.ts\";\nimport type { Ark, keywords, type } from \"./keywords/keywords.ts\";\nimport type { MatchParser } from \"./match.ts\";\nimport type { NaryIntersectionParser, NaryMergeParser, NaryPipeParser, NaryUnionParser } from \"./nary.ts\";\nimport type { ArgTwoOperator, IndexZeroOperator, TupleInfixOperator } from \"./parser/tupleExpressions.ts\";\nimport type { InternalScope, ModuleParser, Scope, ScopeParser } from \"./scope.ts\";\nimport type { BaseType } from \"./variants/base.ts\";\nimport type { instantiateType } from \"./variants/instantiate.ts\";\n/** The convenience properties attached to `type` */\nexport type TypeParserAttachments = Omit<TypeParser, never>;\nexport interface TypeParser<$ = {}> extends Ark.boundTypeAttachments<$> {\n    /**\n     * Create a {@link Type} from your definition.\n     *\n     * @example const Person = type({ name: \"string\" })\n     */\n    <const def, r = type.instantiate<def, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * Create a {@link Generic} from a parameter string and body definition.\n     *\n     * @param params A string like \"<t, n extends number>\" specifying the\n     * {@link Generic}'s parameters and any associated constraints via `extends`.\n     *\n     * @param def The definition for the body of the {@link Generic}. Can reference the\n     * parameter names specified in the previous argument in addition to aliases\n     * from its {@link Scope}.\n     *\n     * @example const BoxOf = type(\"<t extends string | number>\", { contents: \"t\" })\n     */\n    <const params extends ParameterString, const def, r = Generic<parseValidGenericParams<params, $>, def, $>>(params: validateParameterString<params, $>, def: type.validate<def, $, baseGenericConstraints<parseValidGenericParams<params, $>>>): r extends infer _ ? _ : never;\n    /**\n     * Create a {@link Type} from a [tuple expression](http://localhost:3000/docs/expressions)\n     * spread as this function's arguments.\n     *\n     * @example type(\"string\", \"|\", { foo: \"number\" })\n     */\n    <const zero, const one, const rest extends array, r = type.instantiate<[zero, one, ...rest], $>>(_0: zero extends IndexZeroOperator ? zero : type.validate<zero, $>, _1: zero extends \"keyof\" ? type.validate<one, $> : zero extends \"instanceof\" ? conform<one, Constructor> : zero extends \"===\" ? conform<one, unknown> : conform<one, ArgTwoOperator>, ..._2: zero extends \"===\" ? rest : zero extends \"instanceof\" ? conform<rest, readonly Constructor[]> : one extends TupleInfixOperator ? one extends \":\" ? [Predicate<distill.In<type.infer<zero, $>>>] : one extends \"=>\" ? [Morph<distill.Out<type.infer<zero, $>>, unknown>] : one extends \"|>\" ? [type.validate<rest[0], $>] : one extends \"@\" ? [TypeMeta.MappableInput, NodeSelector?] : [type.validate<rest[0], $>] : []): r extends infer _ ? _ : never;\n    /**\n     * An alias of the {@link ArkErrors} class, an instance of which is returned when a {@link Type}\n     * is invoked with invalid input.\n     *\n     * @example\n     * const out = myType(data)\n     *\n     * if(out instanceof type.errors) console.log(out.summary)\n     */\n    errors: typeof ArkErrors;\n    hkt: typeof Hkt;\n    keywords: typeof keywords;\n    /**\n     * The {@link Scope} in which definitions passed to this function will be parsed.\n     */\n    $: Scope<$>;\n    /**\n     * An alias of `type` with no type-level validation or inference.\n     *\n     * Useful when wrapping `type` or using it to parse a dynamic definition.\n     */\n    raw(def: unknown): BaseType<any, $>;\n    module: ModuleParser;\n    scope: ScopeParser;\n    define: DefinitionParser<$>;\n    declare: DeclarationParser<$>;\n    generic: GenericParser<$>;\n    match: MatchParser<$>;\n    schema: SchemaParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value strictly equal (`===`) to the argument passed to this function.\n     * @example const foo = type.unit('foo') // {@link Type}<'foo'>\n     * @example const sym: unique symbol = Symbol(); type.unit(sym) // {@link Type}<typeof sym>\n     */\n    unit: UnitTypeParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value strictly equal (`===`) to one of the arguments passed to this function.\n     * @example const enum = type.enumerated('foo', 'bar', obj) // obj is a by-reference object\n     * @example const TupleForm = type(['===', 'foo', 'bar', obj])\n     * @example const ArgsForm = type('===', 'foo', 'bar', obj)\n     */\n    enumerated: EnumeratedTypeParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by one of the Object.values() of the argument passed to this function.\n     *\n     * ‚ö†Ô∏è For TypeScript enum compatibility, values at numeric keys with corresponding numeric values will not be included.\n     * @example const myEnum = type.valueOf(myTsEnum)\n     */\n    valueOf: ValueOfTypeParser<$>;\n    /**\n     * Create a {@link Type} that is satisfied only by a value of a specific class.\n     * @example const array = type.instanceOf(Array)\n     */\n    instanceOf: InstanceOfTypeParser<$>;\n    /**\n     * Create a {@link Type} from a union of definitions\n     * @example const T = type.or(\"string\", \"number\")\n     */\n    or: NaryUnionParser<$>;\n    /**\n     * Create a {@link Type} from an intersection of definitions\n     * @example const T = type.and({ a: \"1\" }, { b: \"2\" })\n     */\n    and: NaryIntersectionParser<$>;\n    /**\n     * Create a {@link Type} by merging object definitions, with later\n     * definitions having precedence for overlapping keys\n     * @example\n     * // Type<{ a: \"3\", b: \"2\", c: \"4\" }>\n     * const T = type.merge({ a: \"1\", b: \"2\" }, { a: \"3\", c: \"4\" })\n     */\n    merge: NaryMergeParser<$>;\n    /**\n     * Create a {@link Type} from a set of morphs (including Types)\n     * @example\n     * // Type<(In: string) => To<object>>\n     * const T = type.pipe(type.string, s => JSON.parse(s), type.object)\n     */\n    pipe: NaryPipeParser<$>;\n    /**\n     * Define a validated function\n     * @example\n     * const len = type.fn(\"string | unknown[]\", \":\", \"number\")(s => s.length)\n     * len(\"foo\") // 3\n     * // TypeScript: boolean is not assignable to string | unknown[]\n     * // Runtime (throws): must be a string or an object (was boolean)\n     * len(true)\n     */\n    fn: FnParser<$>;\n}\nexport declare class InternalTypeParser extends Callable<(...args: unknown[]) => BaseRoot | Generic, TypeParserAttachments> {\n    constructor($: InternalScope);\n}\nexport type UnitTypeParser<$> = <const t>(value: t) => Type<t, $>;\nexport type InstanceOfTypeParser<$> = <const t extends object>(ctor: Constructor<t>) => Type<t, $>;\nexport type EnumeratedTypeParser<$> = <const values extends readonly unknown[]>(...values: values) => Type<values[number], $>;\nexport type ValueOfTypeParser<$> = <const o extends object>(o: o) => Type<o[keyof o], $>;\nexport type DefinitionParser<$> = <const def>(def: type.validate<def, $>) => def;\nexport type SchemaParser<$> = (schema: RootSchema, opts?: BaseParseOptions) => Type<unknown, $>;\nexport type Type<t = unknown, $ = {}> = instantiateType<t, $>;\nexport type TypeConstructor<t = unknown, $ = {}> = new (def: unknown, $: Scope<$>) => Type<t, $>;\nexport declare const Type: TypeConstructor;\n",
  "arktype/scope.ts": "import { BaseScope, type AliasDefEntry, type ArkSchemaRegistry, type ArkSchemaScopeConfig, type BaseNode, type BaseParseContext, type BaseParseContextInput, type BaseParseOptions, type BaseRoot, type GenericAst, type GenericParamAst, type GenericParamDef, type NodeKind, type NodeSchema, type PreparsedNodeResolution, type PrivateDeclaration, type RootKind, type RootSchema, type arkKind, type exportedNameOf, type nodeOfKind, type reducibleKindOf, type toInternalScope, type writeDuplicateAliasError } from \"@ark/schema\";\nimport { type Brand, type ErrorType, type JsonStructure, type anyOrNever, type array, type flattenListable, type noSuggest } from \"@ark/util\";\nimport type { DeclarationParser } from \"./declare.ts\";\nimport { InternalFnParser, type FnParser } from \"./fn.ts\";\nimport { type GenericDeclaration, type GenericParser, type ParameterString, type baseGenericConstraints, type parseGenericParams, type parseValidGenericParams } from \"./generic.ts\";\nimport type { Ark, type } from \"./keywords/keywords.ts\";\nimport { InternalMatchParser, type MatchParser } from \"./match.ts\";\nimport type { BoundModule, Module, Submodule, exportScope, instantiateExport } from \"./module.ts\";\nimport type { NaryIntersectionParser, NaryMergeParser, NaryPipeParser, NaryUnionParser } from \"./nary.ts\";\nimport type { DefAst, InferredAst } from \"./parser/ast/infer.ts\";\nimport { type inferDefinition } from \"./parser/definition.ts\";\nimport type { ParsedOptionalProperty } from \"./parser/property.ts\";\nimport type { ParsedDefaultableProperty } from \"./parser/shift/operator/default.ts\";\nimport { InternalTypeParser, type DefinitionParser, type EnumeratedTypeParser, type InstanceOfTypeParser, type SchemaParser, type TypeParser, type UnitTypeParser, type ValueOfTypeParser } from \"./type.ts\";\n/** The convenience properties attached to `scope` */\nexport type ScopeParserAttachments = Omit<ScopeParser, never>;\nexport interface ArkScopeConfig extends ArkSchemaScopeConfig {\n}\nexport interface ScopeParser {\n    <const def>(def: scope.validate<def>, config?: ArkScopeConfig): Scope<scope.infer<def>>;\n    define: <const def>(def: scope.validate<def>) => def;\n}\nexport type ModuleParser = <const def>(def: scope.validate<def>, config?: ArkScopeConfig) => scope.infer<def> extends infer $ ? Module<{\n    [k in exportedNameOf<$>]: $[k];\n}> : never;\nexport type bindThis<def> = {\n    this: Def<def>;\n};\n/** nominal type for an unparsed definition used during scope bootstrapping */\ntype Def<def = {}> = Brand<def, \"unparsed\">;\n/** sentinel indicating a scope that will be associated with a generic has not yet been parsed */\nexport type UnparsedScope = \"$\";\n/** These are legal as values of a scope but not as definitions in other contexts */\ntype PreparsedResolution = PreparsedNodeResolution;\ntype bootstrapAliases<def> = {\n    [k in Exclude<keyof def, GenericDeclaration>]: def[k] extends (PreparsedResolution) ? def[k] extends {\n        t: infer g extends GenericAst;\n    } ? g : def[k] extends Module<infer $> | BoundModule<infer $, any> ? Submodule<$> : def[k] : def[k] extends (() => infer thunkReturn extends PreparsedResolution) ? thunkReturn extends {\n        t: infer g extends GenericAst;\n    } ? g : thunkReturn extends Module<infer $> | BoundModule<infer $, any> ? Submodule<$> : thunkReturn : Def<def[k]>;\n} & {\n    [k in keyof def & GenericDeclaration as extractGenericName<k>]: GenericAst<parseValidGenericParams<extractGenericParameters<k>, bootstrapAliases<def>>, def[k], UnparsedScope>;\n};\ntype inferBootstrapped<$> = {\n    [name in keyof $]: $[name] extends Def<infer def> ? inferDefinition<def, $, {}> : $[name] extends {\n        t: infer g extends GenericAst;\n    } ? bindGenericToScope<g, $> : $[name];\n} & unknown;\nexport type bindGenericToScope<g extends GenericAst, $> = GenericAst<g[\"paramsAst\"], g[\"bodyDef\"], g[\"$\"] extends UnparsedScope ? $ : g[\"$\"], $>;\ntype extractGenericName<k> = k extends GenericDeclaration<infer name> ? name : never;\ntype extractGenericParameters<k> = k extends `${string}<${infer params}>` ? ParameterString<params> : never;\nexport type resolutionToAst<alias extends string, resolution> = [\n    resolution\n] extends [anyOrNever] ? InferredAst<resolution, alias> : resolution extends Def<infer def> ? DefAst<def, alias> : resolution extends {\n    [arkKind]: \"module\";\n    root: infer root;\n} ? InferredAst<root, alias> : resolution extends GenericAst ? resolution : InferredAst<resolution, alias>;\nexport type moduleKeyOf<$> = {\n    [k in keyof $]: $[k] extends {\n        [arkKind]: \"module\";\n    } ? [\n        $[k]\n    ] extends [anyOrNever] ? never : k & string : never;\n}[keyof $];\nexport interface ArkTypeRegistry extends ArkSchemaRegistry {\n    typeAttachments?: Ark.boundTypeAttachments<any>;\n    ambient: exportScope<Ark>;\n}\nexport declare const $arkTypeRegistry: ArkTypeRegistry;\nexport interface InternalScope {\n    constructor: typeof InternalScope;\n}\nexport declare class InternalScope<$ extends {} = {}> extends BaseScope<$> {\n    get ambientAttachments(): Ark.boundTypeAttachments<$> | undefined;\n    protected preparseOwnAliasEntry(alias: string, def: unknown): AliasDefEntry;\n    parseGenericParams(def: string, opts: BaseParseOptions): array<GenericParamDef>;\n    protected normalizeRootScopeValue(resolution: unknown): unknown;\n    protected preparseOwnDefinitionFormat(def: unknown, opts: BaseParseOptions): BaseRoot | BaseParseContextInput;\n    parseOwnDefinitionFormat(def: unknown, ctx: BaseParseContext): BaseRoot;\n    unit: UnitTypeParser<$>;\n    valueOf: ValueOfTypeParser<$>;\n    enumerated: EnumeratedTypeParser<$>;\n    instanceOf: InstanceOfTypeParser<$>;\n    or: NaryUnionParser<$>;\n    and: NaryIntersectionParser<$>;\n    merge: NaryMergeParser<$>;\n    pipe: NaryPipeParser<$>;\n    fn: InternalFnParser;\n    match: InternalMatchParser;\n    declare: () => {\n        type: InternalTypeParser;\n    };\n    define<def>(def: def): def;\n    type: InternalTypeParser;\n    static scope: ScopeParser;\n    static module: ModuleParser;\n}\nexport declare const scope: ScopeParser;\nexport declare namespace scope {\n    type validate<def> = {\n        [k in keyof def]: k extends noSuggest ? unknown : parseScopeKey<k, def>[\"params\"] extends infer params ? params extends array<GenericParamAst> ? params[\"length\"] extends 0 ? def[k] extends type.Any | PreparsedResolution ? def[k] : k extends (PrivateDeclaration<infer name extends keyof def & string>) ? ErrorType<writeDuplicateAliasError<name>> : type.validate<def[k], bootstrapAliases<def>, {}> : type.validate<def[k], bootstrapAliases<def>, baseGenericConstraints<params>> : params : never;\n    };\n    type infer<def> = inferBootstrapped<bootstrapAliases<def>>;\n}\nexport interface Scope<$ = {}> {\n    t: $;\n    [arkKind]: \"scope\";\n    config: ArkScopeConfig;\n    references: readonly BaseNode[];\n    json: JsonStructure;\n    exportedNames: array<exportedNameOf<$>>;\n    /** The set of names defined at the root-level of the scope mapped to their\n     * corresponding definitions.**/\n    aliases: Record<string, unknown>;\n    internal: toInternalScope<$>;\n    defineSchema<const def extends RootSchema>(schema: def): def;\n    node<kinds extends NodeKind | array<RootKind>>(kinds: kinds, schema: NodeSchema<flattenListable<kinds>>, opts?: BaseParseOptions): nodeOfKind<reducibleKindOf<flattenListable<kinds>>>;\n    unit: UnitTypeParser<$>;\n    enumerated: EnumeratedTypeParser<$>;\n    valueOf: ValueOfTypeParser<$>;\n    instanceOf: InstanceOfTypeParser<$>;\n    type: TypeParser<$>;\n    match: MatchParser<$>;\n    fn: FnParser<$>;\n    declare: DeclarationParser<$>;\n    define: DefinitionParser<$>;\n    generic: GenericParser<$>;\n    schema: SchemaParser<$>;\n    import(): Module<{\n        [k in exportedNameOf<$> as PrivateDeclaration<k>]: $[k];\n    }>;\n    import<names extends exportedNameOf<$>[]>(...names: names): BoundModule<{\n        [k in names[number] as PrivateDeclaration<k>]: $[k];\n    } & unknown, $>;\n    export(): Module<{\n        [k in exportedNameOf<$>]: $[k];\n    }>;\n    export<names extends exportedNameOf<$>[]>(...names: names): BoundModule<{\n        [k in names[number]]: $[k];\n    } & unknown, $>;\n    resolve<name extends exportedNameOf<$>>(name: name): instantiateExport<$[name], $>;\n}\nexport interface ScopeConstructor {\n    new <$ = {}>(...args: ConstructorParameters<typeof InternalScope>): Scope<$>;\n    scope: ScopeParser;\n    module: ModuleParser;\n}\nexport declare const Scope: ScopeConstructor;\nexport type parseScopeKey<k, def> = k extends `${infer name}<${infer params}>` ? parseGenericScopeKey<name, params, def> : {\n    name: k;\n    params: [];\n};\ntype parseGenericScopeKey<name extends string, params extends string, def> = {\n    name: name;\n    params: parseGenericParams<params, bootstrapAliases<def>>;\n};\nexport type InnerParseResult = BaseRoot | ParsedOptionalProperty | ParsedDefaultableProperty;\nexport {};\n",
  "arktype/module.ts": "import { RootModule, type GenericAst, type PreparsedNodeResolution } from \"@ark/schema\";\nimport type { anyOrNever, inferred } from \"@ark/util\";\nimport type { Generic } from \"./generic.ts\";\nimport type { Type } from \"./type.ts\";\nexport declare const Module: new <$ extends {}>(exports: exportScope<$>) => Module<$>;\nexport interface Module<$ extends {} = {}> extends RootModule<exportScope<$>> {\n}\nexport type exportScope<$> = bindExportsToScope<$, $>;\nexport declare const BoundModule: new <exports extends {}, $ extends {}>(exports: bindExportsToScope<exports, $>, $: $) => BoundModule<exports, $>;\nexport interface BoundModule<exports extends {}, $> extends RootModule<bindExportsToScope<exports, $>> {\n}\nexport type bindExportsToScope<exports, $> = {\n    [k in keyof exports]: instantiateExport<exports[k], $>;\n} & unknown;\nexport type Submodule<exports extends {}> = RootModule<exports & (\"root\" extends keyof exports ? {\n    [inferred]: exports[\"root\"];\n} : {})>;\nexport type instantiateExport<t, $> = [\n    t\n] extends [PreparsedNodeResolution] ? [\n    t\n] extends [anyOrNever] ? Type<t, $> : t extends GenericAst<infer params, infer body, infer body$> ? Generic<params, body, body$, $> : t extends Submodule<infer exports> ? BoundModule<exports, $> : never : Type<t, $>;\n",
  "arktype/generic.ts": "import { GenericRoot, type arkKind, type BaseParseContext, type GenericAst, type GenericParamAst, type GenericParamDef, type genericParamNames, type LazyGenericBody } from \"@ark/schema\";\nimport { type array, type Callable, type conform, type ErrorMessage, type ErrorType, type Hkt, type JsonStructure, type Scanner, type WhitespaceChar } from \"@ark/util\";\nimport type { type } from \"./keywords/keywords.ts\";\nimport type { inferAstRoot } from \"./parser/ast/infer.ts\";\nimport type { validateAst } from \"./parser/ast/validate.ts\";\nimport type { inferDefinition } from \"./parser/definition.ts\";\nimport type { s, StaticState } from \"./parser/reduce/static.ts\";\nimport { parseUntilFinalizer } from \"./parser/string.ts\";\nimport type { Scope } from \"./scope.ts\";\nimport type { Type } from \"./type.ts\";\nexport type ParameterString<params extends string = string> = `<${params}>`;\nexport type extractParams<s extends ParameterString> = s extends ParameterString<infer params> ? params : never;\nexport type validateParameterString<s extends ParameterString, $> = parseGenericParams<extractParams<s>, $> extends infer e extends ErrorMessage ? e : s;\nexport type validateGenericArg<arg, param extends GenericParamAst, $> = type.infer<arg, $> extends param[1] ? unknown : ErrorType<[`Invalid argument for ${param[0]}`, expected: param[1]]>;\nexport type GenericInstantiator<params extends array<GenericParamAst>, def, $, args$> = params[\"length\"] extends 1 ? {\n    <const a, r = instantiateGeneric<def, params, [a], $, args$>>(a: type.validate<a, args$> & validateGenericArg<a, params[0], args$>): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 2 ? {\n    <const a, const b, r = instantiateGeneric<def, params, [a, b], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 3 ? {\n    <const a, const b, const c, r = instantiateGeneric<def, params, [a, b, c], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 4 ? {\n    <const a, const b, const c, const d, r = instantiateGeneric<def, params, [a, b, c, d], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 5 ? {\n    <const a, const b, const c, const d, const e, r = instantiateGeneric<def, params, [a, b, c, d, e], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>,\n        type.validate<e, args$> & validateGenericArg<e, params[4], args$>\n    ]): r extends infer _ ? _ : never;\n} : params[\"length\"] extends 6 ? {\n    <const a, const b, const c, const d, const e, const f, r = instantiateGeneric<def, params, [a, b, c, d, e, f], $, args$>>(...args: [\n        type.validate<a, args$> & validateGenericArg<a, params[0], args$>,\n        type.validate<b, args$> & validateGenericArg<b, params[1], args$>,\n        type.validate<c, args$> & validateGenericArg<c, params[2], args$>,\n        type.validate<d, args$> & validateGenericArg<d, params[3], args$>,\n        type.validate<e, args$> & validateGenericArg<e, params[4], args$>,\n        type.validate<f, args$> & validateGenericArg<f, params[5], args$>\n    ]): r extends infer _ ? _ : never;\n} : (error: ErrorMessage<`You may not define more than 6 positional generic parameters`>) => never;\ntype instantiateGeneric<def, params extends array<GenericParamAst>, args, $, args$> = Type<[\n    def\n] extends [Hkt] ? Hkt.apply<def, {\n    [i in keyof args]: type.infer<args[i], args$>;\n}> : inferDefinition<def, $, bindGenericArgs<params, args$, args>>, args$>;\ntype bindGenericArgs<params extends array<GenericParamAst>, $, args> = {\n    [i in keyof params & `${number}` as params[i][0]]: type.infer<args[i & keyof args], $>;\n};\ntype baseGenericResolutions<params extends array<GenericParamAst>, $> = baseGenericConstraints<params> extends infer baseConstraints ? {\n    [k in keyof baseConstraints]: Type<baseConstraints[k], $>;\n} : never;\nexport type baseGenericConstraints<params extends array<GenericParamAst>> = {\n    [i in keyof params & `${number}` as params[i][0]]: params[i][1];\n};\nexport interface Generic<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = {}, arg$ = $> extends Callable<GenericInstantiator<params, bodyDef, $, arg$>> {\n    [arkKind]: \"generic\";\n    t: GenericAst<params, bodyDef, $, arg$>;\n    bodyDef: bodyDef;\n    params: {\n        [i in keyof params]: [params[i][0], Type<params[i][1], $>];\n    };\n    names: genericParamNames<params>;\n    constraints: {\n        [i in keyof params]: Type<params[i][1], $>;\n    };\n    $: Scope<$>;\n    arg$: Scope<arg$>;\n    internal: GenericRoot;\n    json: JsonStructure;\n}\nexport type GenericConstructor<params extends array<GenericParamAst> = array<GenericParamAst>, bodyDef = unknown, $ = {}, arg$ = {}> = new () => Generic<params, bodyDef, $, arg$>;\nexport declare const Generic: GenericConstructor;\nexport type GenericDeclaration<name extends string = string, params extends ParameterString = ParameterString> = `${name}${params}`;\nexport type parseValidGenericParams<def extends ParameterString, $> = conform<parseGenericParams<extractParams<def>, $>, array<GenericParamAst>>;\nexport declare const emptyGenericParameterMessage = \"An empty string is not a valid generic parameter name\";\nexport type emptyGenericParameterMessage = typeof emptyGenericParameterMessage;\nexport type parseGenericParams<def extends string, $> = parseNextNameChar<Scanner.skipWhitespace<def>, \"\", [\n], $>;\ntype ParamsTerminator = WhitespaceChar | \",\";\nexport declare const parseGenericParamName: (scanner: Scanner, result: GenericParamDef[], ctx: BaseParseContext) => GenericParamDef[];\ntype parseName<unscanned extends string, result extends array<GenericParamAst>, $> = parseNextNameChar<Scanner.skipWhitespace<unscanned>, \"\", result, $>;\ntype parseNextNameChar<unscanned extends string, name extends string, result extends array<GenericParamAst>, $> = unscanned extends `${infer lookahead}${infer nextUnscanned}` ? lookahead extends ParamsTerminator ? name extends \"\" ? ErrorMessage<emptyGenericParameterMessage> : lookahead extends \",\" ? parseName<nextUnscanned, [...result, [name, unknown]], $> : lookahead extends WhitespaceChar ? _parseOptionalConstraint<nextUnscanned, name, result, $> : never : parseNextNameChar<nextUnscanned, `${name}${lookahead}`, result, $> : name extends \"\" ? result : [...result, [name, unknown]];\ndeclare const extendsToken = \"extends \";\ntype extendsToken = typeof extendsToken;\ndeclare const _parseOptionalConstraint: (scanner: Scanner, name: string, result: GenericParamDef[], ctx: BaseParseContext) => GenericParamDef[];\ntype _parseOptionalConstraint<unscanned extends string, name extends string, result extends array<GenericParamAst>, $> = Scanner.skipWhitespace<unscanned> extends (`${extendsToken}${infer nextUnscanned}`) ? parseUntilFinalizer<s.initialize<nextUnscanned>, $, {}> extends (infer finalArgState extends StaticState) ? validateAst<finalArgState[\"root\"], $, {}> extends (infer e extends ErrorMessage) ? e : parseName<finalArgState[\"unscanned\"], [\n    ...result,\n    [name, inferAstRoot<finalArgState[\"root\"], $, {}>]\n], $> : never : parseName<Scanner.skipWhitespace<unscanned> extends `,${infer nextUnscanned}` ? nextUnscanned : unscanned, [\n    ...result,\n    [name, unknown]\n], $>;\ntype genericParamDefToAst<schema extends GenericParamDef, $> = schema extends string ? [schema, unknown] : schema extends readonly [infer name, infer def] ? [name, type.infer<def, $>] : never;\nexport type genericParamDefsToAst<defs extends array<GenericParamDef>, $> = [\n    ...{\n        [i in keyof defs]: genericParamDefToAst<defs[i], $>;\n    }\n];\nexport type GenericParser<$ = {}> = <const paramsDef extends array<GenericParamDef>>(...params: {\n    [i in keyof paramsDef]: paramsDef[i] extends (readonly [infer name, infer def]) ? readonly [name, type.validate<def, $>] : paramsDef[i];\n}) => GenericBodyParser<genericParamDefsToAst<paramsDef, $>, $>;\ninterface GenericBodyParser<params extends array<GenericParamAst>, $> {\n    <const body>(body: type.validate<body, $, baseGenericConstraints<params>>): Generic<params, body, $, $>;\n    <hkt extends Hkt.constructor>(instantiateDef: LazyGenericBody<baseGenericResolutions<params, $>>, hkt: hkt): Generic<params, InstanceType<hkt>, $, $>;\n}\nexport {};\n",
  "arktype/config.ts": "import type { arkKind, TypeMeta } from \"@ark/schema\";\nimport type { Ark } from \"./keywords/keywords.ts\";\nimport { type ArkSchemaConfig } from \"@ark/schema/config\";\nimport type { anyOrNever } from \"@ark/util\";\nexport type KeywordConfig = {\n    [k in keyof Ark.flat as parseConfigurableFlatAlias<k, Ark.flat[k]>]?: TypeMeta.Collapsible;\n};\ntype parseConfigurableFlatAlias<k extends string, v> = [\n    v\n] extends [anyOrNever] ? k : v extends {\n    [arkKind]: \"generic\" | \"module\";\n} ? never : k extends `${infer prefix}.root` ? prefix : k;\nexport interface ArkConfig extends ArkSchemaConfig {\n    keywords?: KeywordConfig;\n}\nexport declare const configure: <config extends ArkConfig>(config: config) => config;\ndeclare global {\n    export interface ArkEnv {\n        $(): Ark;\n    }\n}\n/**\n * This mirrors the global ArkEnv namespace as a local export. We use it instead\n * of the global internally due to a bug in twoslash that prevents `ark/docs`\n * from building if we refer to the global directly.\n *\n * If, in the future, docs can build while arktype refers to `ArkEnv.$` directly,\n * this can be removed.\n */\nexport declare namespace ArkAmbient {\n    type $ = ReturnType<ArkEnv[\"$\"]>;\n    type meta = ArkEnv.meta;\n    type prototypes = ArkEnv.prototypes;\n}\nexport {};\n",
  "arktype/keywords/keywords.ts": "import type { ArkErrors, arkKind, flatResolutionsOf } from \"@ark/schema\";\nimport type { Brand, inferred } from \"@ark/util\";\nimport type { distill, InferredMorph, Out, To } from \"../attributes.ts\";\nimport type { DeclarationParser } from \"../declare.ts\";\nimport type { FnParser } from \"../fn.ts\";\nimport type { GenericParser } from \"../generic.ts\";\nimport type { MatchParser } from \"../match.ts\";\nimport type { BoundModule, Module } from \"../module.ts\";\nimport type { inferDefinition, validateDefinition } from \"../parser/definition.ts\";\nimport { type bindThis, type Scope } from \"../scope.ts\";\nimport type { DefinitionParser, SchemaParser, Type, TypeParser } from \"../type.ts\";\nimport type { BaseType } from \"../variants/base.ts\";\nimport type { instantiateType } from \"../variants/instantiate.ts\";\nimport { arkBuiltins } from \"./builtins.ts\";\nimport { arkPrototypes } from \"./constructors.ts\";\nimport { number } from \"./number.ts\";\nimport { string } from \"./string.ts\";\nimport { arkTsGenerics, arkTsKeywords, object, unknown } from \"./ts.ts\";\nexport interface Ark extends Omit<Ark.keywords, keyof Ark.wrapped>, Ark.wrapped {\n}\nexport declare namespace Ark {\n    interface keywords extends arkTsKeywords.$, arkTsGenerics.$, arkPrototypes.keywords, arkBuiltins.$ {\n    }\n    interface wrapped extends arkPrototypes.wrapped {\n        string: string.submodule;\n        number: number.submodule;\n        object: object.submodule;\n        unknown: unknown.submodule;\n    }\n    type flat = flatResolutionsOf<Ark>;\n    interface typeAttachments extends arkTsKeywords.$ {\n        arrayIndex: arkPrototypes.$[\"Array\"][\"index\"];\n        Key: arkBuiltins.$[\"Key\"];\n        Record: arkTsGenerics.$[\"Record\"];\n        Date: arkPrototypes.$[\"Date\"];\n        Array: arkPrototypes.$[\"Array\"][\"root\"];\n    }\n    interface boundTypeAttachments<$> extends Omit<BoundModule<typeAttachments, $>, arkKind> {\n    }\n}\nexport declare const ark: Scope<Ark>;\nexport declare const keywords: Module<Ark>;\nexport declare const type: TypeParser<{}>;\nexport declare namespace type {\n    interface cast<to> {\n        [inferred]?: to;\n    }\n    type errors = ArkErrors;\n    type validate<def, $ = {}, args = bindThis<def>> = validateDefinition<def, $, args>;\n    type instantiate<def, $ = {}, args = bindThis<def>> = instantiateType<inferDefinition<def, $, args>, $>;\n    type infer<def, $ = {}, args = bindThis<def>> = inferDefinition<def, $, args>;\n    namespace infer {\n        type In<def, $ = {}, args = {}> = distill.In<inferDefinition<def, $, args>>;\n        type Out<def, $ = {}, args = {}> = distill.Out<inferDefinition<def, $, args>>;\n        namespace introspectable {\n            type Out<def, $ = {}, args = {}> = distill.introspectable.Out<inferDefinition<def, $, args>>;\n        }\n    }\n    type brand<t, id> = t extends InferredMorph<infer i, infer o> ? o[\"introspectable\"] extends true ? (In: i) => To<Brand<o[\"t\"], id>> : (In: i) => Out<Brand<o[\"t\"], id>> : Brand<t, id>;\n    /** @ts-ignore cast variance */\n    interface Any<out t = any, $ = any> extends BaseType<t, $> {\n    }\n}\nexport type type<t = unknown, $ = {}> = Type<t, $>;\nexport declare const match: MatchParser<{}>;\nexport declare const fn: FnParser<{}>;\nexport declare const generic: GenericParser<{}>;\nexport declare const schema: SchemaParser<{}>;\nexport declare const define: DefinitionParser<{}>;\nexport declare const declare: DeclarationParser<{}>;\n",
  "arktype/variants/base.ts": "import type { BaseNode, BaseRoot, Disjoint, JsonSchema, NodeSelector, Predicate, StandardSchemaV1, ToJsonSchema, TypeMeta, UndeclaredKeyBehavior } from \"@ark/schema\";\nimport type { anyOrNever, array, Callable, ErrorMessage, inferred, JsonStructure, unset } from \"@ark/util\";\nimport type { defaultFor, distill, inferIntersection, inferPipe, InferredMorph, Out, To } from \"../attributes.ts\";\nimport type { ArkAmbient } from \"../config.ts\";\nimport type { type } from \"../keywords/keywords.ts\";\nimport type { NaryPipeParser } from \"../nary.ts\";\nimport type { Scope } from \"../scope.ts\";\nimport type { ArrayType } from \"./array.ts\";\nimport type { instantiateType } from \"./instantiate.ts\";\n/** @ts-ignore cast variance */\nexport interface Inferred<out t = unknown, $ = {}> {\n    internal: BaseRoot;\n    [inferred]: t;\n    /**\n     * precompiled JS used to optimize validation\n     *\n     * ‚ö†Ô∏è will be `undefined` in [jitless](https://arktype.io/docs/configuration#jitless) mode\n     */\n    precompilation: string | undefined;\n    /**\n     * generic parameter representing this Type\n     *\n     * ü•∏ inference-only property that will be `undefined` at runtime\n     *\n     * ‚ö†Ô∏è May contain types representing morphs or default values that would\n     * be inaccurate if used directly for runtime values. In those cases,\n     * you should use {@link infer} or {@link inferIn} on this object instead.\n     */\n    t: t;\n    /**\n     * #### {@link Scope} in which chained methods are parsed\n     */\n    $: Scope<$>;\n    /**\n     * #### type of output this returns\n     *\n     * ü•∏ inference-only property that will be `undefined` at runtime\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type ParsedNumber = typeof parseNumber.infer // number\n     */\n    infer: this[\"inferOut\"];\n    /**\n     * type of output this returns\n     *\n     * üîó alias of {@link infer}\n     * ü•∏ inference-only property that will be `undefined` at runtime\n     *\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type ParsedNumber = typeof parseNumber.infer // number\n     */\n    inferOut: distill.Out<t>;\n    /**\n     * type of output that can be introspected at runtime (e.g. via {@link out})\n     *\n     * ‚ö†Ô∏è If your Type contains morphs, they will be inferred as `unknown` unless\n     * they are an ArkType keyword or have an explicitly defined output validator.\n     *\n     * ü•∏ inference-only property that will be `undefined` at runtime\n     *\n     * @example\n     * const Unmorphed = type(\"string\")\n     * // with no morphs, we can introspect the input and output as a single Type\n     * type UnmorphedOut = typeof Unmorphed.inferIntrospectableOut // string\n     *\n     * const Morphed = type(\"string\").pipe(s => s.length)\n     * // with a standard user-defined morph, TypeScript can infer a\n     * // return type from your function, but we have no way to\n     * // know the shape at runtime\n     * type MorphOut = typeof Morphed.inferIntrospectableOut  // unknown\n     *\n     * const Validated = type(\"string\").pipe(s => s.length).to(\"number\")\n     * // morphs with validated output, including all morph keywords, are introspectable\n     * type ValidatedMorphOut = typeof Validated.inferIntrospectableOut\n     */\n    inferIntrospectableOut: distill.introspectable.Out<t>;\n    /**\n     * #### type of input this allows\n     *\n     * ü•∏ inference-only property that will be `undefined` at runtime\n     *\n     * @example\n     * const parseNumber = type(\"string\").pipe(s => Number.parseInt(s))\n     * type UnparsedNumber = typeof parseNumber.inferIn // string\n     */\n    inferIn: distill.In<t>;\n    /**\n     * #### internal JSON representation\n     */\n    json: JsonStructure;\n    /**\n     * alias of {@link json} for `JSON.stringify` compatibility\n     */\n    toJSON(): JsonStructure;\n    /**\n     * #### generate a JSON Schema\n     *\n     * @throws {ToJsonSchema.Error} if this cannot be converted to JSON Schema\n     */\n    toJsonSchema(options?: ToJsonSchema.Options): JsonSchema;\n    /**\n     * #### metadata like custom descriptions and error messages\n     *\n     * ‚úÖ type {@link https://arktype.io/docs/configuration#custom | can be customized} for your project\n     */\n    meta: ArkAmbient.meta;\n    /**\n     * #### human-readable English description\n     *\n     * ‚úÖ works best for primitive values\n     *\n     * @example\n     * const N = type(\"0 < number <= 100\")\n     * console.log(N.description) // positive and at most 100\n     */\n    description: string;\n    /**\n     * #### syntax string similar to native TypeScript\n     *\n     * ‚úÖ works well for both primitives and structures\n     *\n     * @example\n     * const Loc = type({ coords: [\"number\", \"number\"] })\n     * console.log(Loc.expression) // { coords: [number, number] }\n     */\n    expression: string;\n    /**\n     * #### validate and return transformed data or throw\n     *\n     * ‚úÖ sugar to avoid checking for {@link type.errors} if they are unrecoverable\n     *\n     * @example\n     * const CriticalPayload = type({\n     *     superImportantValue: \"string\"\n     * })\n     * // throws TraversalError: superImportantValue must be a string (was missing)\n     * const data = CriticalPayload.assert({ irrelevantValue: \"whoops\" })\n     * console.log(data.superImportantValue) // valid output can be accessed directly\n     *\n     * @throws {TraversalError}\n     */\n    assert: (data: unknown) => this[\"infer\"];\n    /**\n     * #### check input without applying morphs\n     *\n     * ‚úÖ good for stuff like filtering that doesn't benefit from detailed errors\n     *\n     * @example\n     * const Numeric = type(\"number | bigint\")\n     * // [0, 2n]\n     * const numerics = [0, \"one\", 2n].filter(Numeric.allows)\n     */\n    allows: (data: unknown) => data is this[\"inferIn\"];\n    /**\n     * #### add metadata to shallow references\n     *\n     * ‚ö†Ô∏è does not affect error messages within properties of an object\n     *\n     * @example\n     * const NotOdd = type(\"number % 2\").configure({ description: \"not odd\" })\n     * // all constraints at the root are affected\n     * const odd = NotOdd(3) // must be not odd (was 3)\n     * const nonNumber = NotOdd(\"two\") // must be not odd (was \"two\")\n     *\n     * const NotOddBox = type({\n     *    // we should have referenced notOdd or added meta here\n     *    notOdd: \"number % 2\",\n     * // but instead chained from the root object\n     * }).configure({ description: \"not odd\" })\n     * // error message at path notOdd is not affected\n     * const oddProp = NotOddBox({ notOdd: 3 }) // notOdd must be even (was 3)\n     * // error message at root is affected, leading to a misleading description\n     * const nonObject = NotOddBox(null) // must be not odd (was null)\n     */\n    configure: NodeSelector.SelectableFn<TypeMeta.MappableInput, this>;\n    /**\n     * #### add description to shallow references\n     *\n     * üîó equivalent to `.configure({ description })` (see {@link configure})\n     * ‚ö†Ô∏è does not affect error messages within properties of an object\n     *\n     * @example\n     * const AToZ = type(/^a.*z$/).describe(\"a string like 'a...z'\")\n     * const good = AToZ(\"alcatraz\") // \"alcatraz\"\n     * // ArkErrors: must be a string like 'a...z' (was \"albatross\")\n     * const badPattern = AToZ(\"albatross\")\n     */\n    describe: NodeSelector.SelectableFn<string, this>;\n    /**\n     * #### apply undeclared key behavior\n     *\n     * - `\"ignore\"` (default) - allow and preserve extra properties\n     * - `\"reject\"` - disallow extra properties\n     * - `\"delete\"` - clone and remove extra properties from output\n     */\n    onUndeclaredKey(behavior: UndeclaredKeyBehavior): this;\n    /**\n     * #### deeply apply undeclared key behavior\n     *\n     * - `\"ignore\"` (default) - allow and preserve extra properties\n     * - `\"reject\"` - disallow extra properties\n     * - `\"delete\"` - clone and remove extra properties from output\n     */\n    onDeepUndeclaredKey(behavior: UndeclaredKeyBehavior): this;\n    /**\n     * #### alias for {@link assert} with typed input\n     *\n     * @example\n     * const T = type({ foo: \"string\" });\n     * // TypeScript: foo must be a string (was 5)\n     * const data = T.from({ foo: 5 });\n     */\n    from(literal: this[\"inferIn\"]): this[\"infer\"];\n    /**\n     * #### deeply extract inputs\n     *\n     * ‚úÖ will never include morphs\n     * ‚úÖ good for generating JSON Schema or other non-transforming formats\n     *\n     * @example\n     * const User = type({\n     *    age: \"string.numeric.parse\"\n     * })\n     * // { age: 25 } (age parsed to a number)\n     * const out = User({ age: \"25\" })\n     * // { age: \"25\" } (age is still a string)\n     * const inOut = User.in({ age: \"25\" })\n     */\n    get in(): instantiateType<this[\"inferIn\"], $>;\n    /**\n     * #### deeply extract outputs\n     *\n     * ‚úÖ will never include morphs\n     * ‚ö†Ô∏è if your type includes morphs, their output will likely be unknown unless they\n     * were defined with an explicit output validator via `.to(outputDef)` or `.pipe(morph, outputType)`\n     *\n     * @example\n     * const join = type(\"string[]\").pipe(a => a.join(\",\"))\n     *\n     * const T = type({\n     *    // all keywords have introspectable output\n     *    keyword: \"string.numeric.parse\",\n     *    // TypeScript knows this returns a string, but we can't introspect that at runtime\n     *    unvalidated: join,\n     *    // if needed, it can be made introspectable with an output validator\n     *    validated: join.to(\"string\")\n     * })\n     *\n     * // Type<{ keyword: number; unvalidated: unknown; validated: string }>\n     * const baseOut = base.out\n     */\n    get out(): instantiateType<this[\"inferIntrospectableOut\"], $>;\n    /**\n     * #### add a compile-time brand to output\n     *\n     * ü•∏ inference-only function that does nothing runtime\n     *\n     * @example\n     * const Palindrome = type(\"string\")\n     *     .narrow(s => s === [...s].reverse().join(\"\"))\n     *     .brand(\"palindrome\")\n     * // Brand<string, \"palindrome\">\n     * const out = Palindrome.assert(\"racecar\")\n     */\n    brand<const name extends string, r = instantiateType<type.brand<t, name>, $>>(name: name): r extends infer _ ? _ : never;\n    /**\n     * #### an array of this\n     *\n     * @example\n     * // Type<{ rebmun: number }[]>\n     * const T = type({ rebmun: \"number\" }).array();\n     */\n    array(): ArrayType<t[], $>;\n    /**\n     * #### {@link https://arktype.io/docs/objects#properties-optional | optional definition}\n     *\n     * ‚ö†Ô∏è unlike most other methods, this creates a definition rather than a Type (read why)\n     *\n     * @example\n     * const Prop = type({ foo: \"number\" })\n     * // Type<{ bar?: { foo: number } }>\n     * const Obj = type({ bar: Prop.optional() })\n     */\n    optional(): [this, \"?\"];\n    /**\n     * #### {@link https://arktype.io/docs/objects#properties-defaultable | defaultable definition}\n     *\n     * ‚úÖ object defaults can be returned from a function\n     * ‚ö†Ô∏è throws if the default value is not allowed\n     * ‚ö†Ô∏è unlike most other methods, this creates a definition rather than a Type (read why)\n     *\n     * @example\n     * // Type<{ count: Default<number, 0> }>\n     * const State = type({ count: type.number.default(0) })\n     * const Prop = type({ nested: \"boolean\" })\n     * const ForObj = type({\n     *     key: Prop.default(() => ({ nested: false }))\n     * })\n     */\n    default<const value extends defaultFor<this[\"inferIn\"]>>(value: value): [this, \"=\", value];\n    /**\n     * #### apply a predicate function to input\n     *\n     * ‚ö†Ô∏è the behavior of {@link narrow}, this method's output counterpart, is usually more desirable\n     * ‚úÖ most useful for morphs with input types that are re-used externally\n     * ü•∏ {@link https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates | Type predicates} can be used as casts\n     *\n     * @example\n     * const stringifyUser = type({ name: \"string\" }).pipe(user => JSON.stringify(user))\n     * const stringifySafe = stringifyUser.filter(user => user.name !== \"Bobby Tables\")\n     * // Type<(In: `${string}Z`) => To<Date>>\n     * const WithPredicate = type(\"string.date.parse\").filter((s): s is `${string}Z` =>\n     *     s.endsWith(\"Z\")\n     * )\n     */\n    filter<narrowed extends this[\"inferIn\"] = never, r = instantiateType<[\n        narrowed\n    ] extends [never] ? t : t extends InferredMorph<never, infer o> ? (In: narrowed) => o : narrowed, $>>(predicate: Predicate.Castable<this[\"inferIn\"], narrowed>): r extends infer _ ? _ : never;\n    /**\n     * #### apply a predicate function to output\n     *\n     * ‚úÖ go-to fallback for validation not composable via built-in types and operators\n     * ‚úÖ runs after all other validators and morphs, if present\n     * ü•∏ {@link https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates | Type predicates} can be used as casts\n     *\n     * @example\n     * const Palindrome = type(\"string\").narrow(s => s === [...s].reverse().join(\"\"))\n     *\n     * const PalindromicEmail = type(\"string.date.parse\").narrow((date, ctx) =>\n     * \t\tdate.getFullYear() === 2025 || ctx.mustBe(\"the current year\")\n     * )\n     * // Type<`${string}.tsx`>\n     * const WithPredicate = type(\"string\").narrow((s): s is `${string}.tsx` => /\\.tsx?$/.test(s))\n     */\n    narrow<narrowed extends this[\"infer\"] = never, r = instantiateType<[\n        narrowed\n    ] extends [never] ? t : t extends InferredMorph<infer i, infer o> ? o extends To ? (In: i) => To<narrowed> : (In: i) => Out<narrowed> : narrowed, $>>(predicate: Predicate.Castable<this[\"infer\"], narrowed>): r extends infer _ ? _ : never;\n    /**\n     * #### pipe output through arbitrary transformations or other Types\n     *\n     * @example\n     * const User = type({ name: \"string\" })\n     *\n     * // parse a string and validate that the result as a user\n     * const parseUser = type(\"string\").pipe(s => JSON.parse(s), user)\n     */\n    pipe: ChainedPipeParser<$, t>;\n    /**\n     * #### parse a definition as an output validator\n     *\n     * üîó `to({ name: \"string\" })` is equivalent to `.pipe(type({ name: \"string\" }))`\n     *\n     * @example\n     * // parse a string and validate that the result as a user\n     * const parseUser = type(\"string\").pipe(s => JSON.parse(s)).to({ name: \"string\" })\n     */\n    to<const def, r = instantiateType<inferPipe<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * #### query internal node references\n     *\n     * @experimental filters and returns the Type's internal representation from `@ark/schema`\n     *\n     * @example\n     * // [\"blue\", \"red\"]\n     * const values = type(\"'red' | 'blue'\").select(\"unit\").map(u => u.unit)\n     */\n    select: BaseNode[\"select\"];\n}\n/** @ts-ignore cast variance */\ninterface Type<out t = unknown, $ = {}> extends Callable<(data: unknown) => distill.Out<t> | ArkEnv.onFail>, Inferred<t, $> {\n    /**\n     * #### cast the way this is inferred\n     *\n     * ü•∏ inference-only function that does nothing runtime\n     *\n     * @example\n     * // Type<`LEEEEEEEE${string}ROY`>\n     * const Leeroy = type(/^LE{8,}ROY$/).as<`LEEEEEEEE${string}ROY`>()\n     */\n    as<castTo = unset>(...args: validateChainedAsArgs<castTo>): instantiateType<castTo, $>;\n    /**\n     * #### intersect the parsed Type, throwing if the result is unsatisfiable\n     *\n     * @example\n     * // Type<{ foo: number; bar: string }>\n     * const T = type({ foo: \"number\" }).and({ bar: \"string\" })\n     * // ParseError: Intersection at foo of number and string results in an unsatisfiable type\n     * const Bad = type({ foo: \"number\" }).and({ foo: \"string\" })\n     */\n    and<const def, r = instantiateType<inferIntersection<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * #### union with the parsed Type\n     *\n     * ‚ö†Ô∏è a union that could apply different morphs to the same data is a ParseError ({@link https://arktype.io/docs/expressions#union-morphs | docs})\n     *\n     * @example\n     * // Type<string | { box: string }>\n     * const T = type(\"string\").or({ box: \"string\" })\n     */\n    or<const def, r = instantiateType<t | type.infer<def, $>, $>>(def: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * #### intersect the parsed Type, returning an introspectable {@link Disjoint} if the result is unsatisfiable\n     *\n     * @example\n     * // Type<{ foo: number; bar: string }>\n     * const T = type({ foo: \"number\" }).intersect({ bar: \"string\" })\n     * const Bad = type(\"number > 10\").intersect(\"number < 5\")\n     * // logs \"Intersection of > 10 and < 5 results in an unsatisfiable type\"\n     * if (Bad instanceof Disjoint) console.log(`${bad.summary}`)\n     */\n    intersect<const def, r = instantiateType<inferIntersection<t, type.infer<def, $>>, $>>(def: type.validate<def, $>): r extends infer _ ? _ | Disjoint : never;\n    /**\n     * #### check if the parsed Type's constraints are identical\n     *\n     * ‚úÖ equal types have identical input and output constraints and transforms\n     * ‚úÖ ignores associated {@link meta}, which does not affect the set of allowed values\n     *\n     * @example\n     * const DivisibleBy6 = type.number.divisibleBy(6).moreThan(0)\n     * // false (left side must also be positive)\n     * DivisibleBy6.equals(\"number % 6\")\n     * // false (right side has an additional <100 constraint)\n     * console.log(DivisibleBy6.equals(\"0 < (number % 6) < 100\"))\n     * const ThirdTry = type(\"(number % 2) > 0\").divisibleBy(3)\n     * // true (types are normalized and reduced)\n     * console.log(DivisibleBy6.equals(ThirdTry))\n     */\n    equals<const def>(def: type.validate<def, $>): boolean;\n    /**\n     * #### narrow this based on an {@link equals} check\n     *\n     * ‚úÖ ignores associated {@link meta}, which does not affect the set of allowed values\n     *\n     * @example\n     * const N = type.raw(`${Math.random()}`)\n     * // Type<0.5> | undefined\n     * const Ez = N.ifEquals(\"0.5\")\n     */\n    ifEquals<const def, r = type.instantiate<def, $>>(def: type.validate<def, $>): r extends infer _ ? _ | undefined : never;\n    /**\n     * #### check if this is a subtype of the parsed Type\n     *\n     * ‚úÖ a subtype must include all constraints from the base type\n     * ‚úÖ unlike {@link equals}, additional constraints may be present\n     * ‚úÖ ignores associated {@link meta}, which does not affect the set of allowed values\n     *\n     * @example\n     * type.string.extends(\"unknown\") // true\n     * type.string.extends(/^a.*z$/) // false\n     */\n    extends<const def>(other: type.validate<def, $>): boolean;\n    /**\n     * #### narrow this based on an {@link extends} check\n     *\n     * ‚úÖ ignores associated {@link meta}, which does not affect the set of allowed values\n     *\n     * @example\n     * const N = type(Math.random() > 0.5 ? \"true\" : \"0\") // Type<0 | true>\n     * const Ez = N.ifExtends(\"boolean\") // Type<true> | undefined\n     */\n    ifExtends<const def, r = type.instantiate<def, $>>(other: type.validate<def, $>): r extends infer _ ? _ | undefined : never;\n    /**\n     * #### check if a value could satisfy this and the parsed Type\n     *\n     * ‚ö†Ô∏è will return true unless a {@link Disjoint} can be proven\n     *\n     * @example\n     * type.string.overlaps(\"string | number\") // true (e.g. \"foo\")\n     * type(\"string | number\").overlaps(\"1\") // true (1)\n     * type(\"number > 0\").overlaps(\"number < 0\") // false (no values exist)\n     *\n     * const NoAt = type(\"string\").narrow(s => !s.includes(\"@\"))\n     * NoAt.overlaps(\"string.email\") // true (no values exist, but not provable)\n     */\n    overlaps<const def>(r: type.validate<def, $>): boolean;\n    /**\n     * #### extract branches {@link extend}ing the parsed Type\n     *\n     * @example\n     * // Type<true | 0 | 2>\n     * const T = type(\"boolean | 0 | 'one' | 2 | bigint\").extract(\"number | 0n | true\")\n     */\n    extract<const def, r = instantiateType<t extends type.infer<def, $> ? t : never, $>>(r: type.validate<def, $>): r extends infer _ extends r ? _ : never;\n    /**\n     * #### exclude branches {@link extend}ing the parsed Type\n     *\n     * @example\n     *\n     * // Type<false | 'one' | bigint>\n     * const T = type(\"boolean | 0 | 'one' | 2 | bigint\").exclude(\"number | 0n | true\")\n     */\n    exclude<const def, r = instantiateType<t extends type.infer<def, $> ? never : t, $>>(r: type.validate<def, $>): r extends infer _ ? _ : never;\n    /**\n     * @experimental\n     * Map and optionally reduce branches of a union. Types that are not unions\n     * are treated as a single branch.\n     *\n     * @param mapBranch - the mapping function, accepting a branch Type\n     *     Returning another `Type` is common, but any value can be returned and\n     *     inferred as part of the output.\n     *\n     * @param [reduceMapped] - an operation to perform on the mapped branches\n     *     Can be used to e.g. merge an array of returned Types representing\n     *     branches back to a single union.\n     */\n    distribute<mapOut, reduceOut = mapOut[]>(mapBranch: (branch: Type, i: number, branches: array<Type>) => mapOut, reduceMapped?: (mappedBranches: mapOut[]) => reduceOut): reduceOut;\n    /** The Type's [StandardSchema](https://github.com/standard-schema/standard-schema) properties */\n    \"~standard\": StandardSchemaV1.ArkTypeProps<this[\"inferIn\"] extends infer _ ? _ : never, this[\"inferOut\"] extends infer _ ? _ : never>;\n    /** @deprecated */\n    apply: Function[\"apply\"];\n    /** @deprecated */\n    bind: Function[\"bind\"];\n    /** @deprecated */\n    call: Function[\"call\"];\n    /** @deprecated */\n    caller: Function;\n    /** @deprecated */\n    length: number;\n    /** @deprecated */\n    name: string;\n    /** @deprecated */\n    prototype: Function[\"prototype\"];\n    /** @deprecated */\n    arguments: Function[\"arguments\"];\n    /** @deprecated */\n    Symbol: never;\n}\nexport interface ChainedPipeParser<$, t> extends NaryPipeParser<$, t> {\n    try: NaryPipeParser<$, t>;\n}\ntype validateChainedAsArgs<t> = [\n    t\n] extends [unset] ? [\n    t\n] extends [anyOrNever] ? [\n] : [\n    ErrorMessage<\"as requires an explicit type parameter like myType.as<t>()\">\n] : [];\nexport type { Type as BaseType };\n",
  "arktype/parser/definition.ts": "import { type BaseParseContext, type BaseRoot, type StandardSchemaV1 } from \"@ark/schema\";\nimport { type anyOrNever, type array, type ErrorMessage, type Fn, type ifEmptyObjectLiteral, type objectKindOrDomainOf, type Primitive } from \"@ark/util\";\nimport type { Out } from \"../attributes.ts\";\nimport type { type } from \"../keywords/keywords.ts\";\nimport type { InnerParseResult } from \"../scope.ts\";\nimport type { shallowDefaultableMessage, shallowOptionalMessage, validateString } from \"./ast/validate.ts\";\nimport { type inferObjectLiteral, type validateObjectLiteral } from \"./objectLiteral.ts\";\nimport type { isDefaultable, OptionalPropertyDefinition } from \"./property.ts\";\nimport { type BaseCompletions, type inferString } from \"./string.ts\";\nimport { type inferTupleExpression, type maybeValidateTupleExpression, type TupleExpression } from \"./tupleExpressions.ts\";\nimport { type inferTupleLiteral, type validateTupleLiteral } from \"./tupleLiteral.ts\";\nexport declare const parseInnerDefinition: (def: unknown, ctx: BaseParseContext) => InnerParseResult;\nexport declare const parseObject: (def: object, ctx: BaseParseContext) => BaseRoot;\nexport type inferDefinition<def, $, args> = [\n    def\n] extends [anyOrNever] ? def : def extends type.cast<infer t> ? ifEmptyObjectLiteral<def, object, t> : def extends ThunkCast<infer t> ? t : def extends string ? inferString<def, $, args> : def extends array ? inferTuple<def, $, args> : def extends RegExp ? string : def extends StandardSchemaV1 ? inferStandardSchema<def> : def extends object ? inferObjectLiteral<def, $, args> : never;\ntype inferStandardSchema<schema extends StandardSchemaV1, i = StandardSchemaV1.InferInput<schema>, o = StandardSchemaV1.InferOutput<schema>> = [i, o] extends [o, i] ? i : (In: i) => Out<o>;\nexport type validateDefinition<def, $, args> = null extends undefined ? ErrorMessage<`'strict' or 'strictNullChecks' must be set to true in your tsconfig's 'compilerOptions'`> : [def] extends [anyOrNever] ? def : def extends OptionalPropertyDefinition ? ErrorMessage<shallowOptionalMessage> : isDefaultable<def, $, args> extends true ? ErrorMessage<shallowDefaultableMessage> : validateInnerDefinition<def, $, args>;\nexport type validateInnerDefinition<def, $, args> = [\n    def\n] extends [TerminalObjectDefinition] ? def : def extends string ? validateString<def, $, args> : unknown extends def ? BaseCompletions<$, args> | {} : def extends readonly unknown[] ? validateTuple<def, $, args> : def extends BadDefinitionType ? ErrorMessage<writeBadDefinitionTypeMessage<objectKindOrDomainOf<def>>> : validateObjectLiteral<def, $, args>;\nexport declare const parseTuple: (def: array, ctx: BaseParseContext) => BaseRoot;\nexport type validateTuple<def extends array, $, args> = maybeValidateTupleExpression<def, $, args> extends infer result ? result extends null ? validateTupleLiteral<def, $, args> : result : never;\nexport type inferTuple<def extends array, $, args> = def extends TupleExpression ? inferTupleExpression<def, $, args> : inferTupleLiteral<def, $, args>;\nexport type TerminalObjectDefinition = type.cast<unknown> | Fn | RegExp | StandardSchemaV1;\nexport type ThunkCast<t = unknown> = () => type.cast<t>;\ntype BadDefinitionType = Exclude<Primitive, string>;\nexport declare const writeBadDefinitionTypeMessage: <actual extends string>(actual: actual) => writeBadDefinitionTypeMessage<actual>;\ntype writeBadDefinitionTypeMessage<actual extends string> = `Type definitions must be strings or objects (was ${actual})`;\nexport {};\n",
  "arktype/attributes.ts": "import type { ArkError, ArkErrors, Morph } from \"@ark/schema\";\nimport { type anyOrNever, type array, type Brand, type equals, type Hkt, type intersectArrays, type isSafelyMappable, type merge, type optionalKeyOf, type Primitive, type show, type unionKeyOf, type unionToTuple } from \"@ark/util\";\nimport type { arkPrototypes } from \"./keywords/constructors.ts\";\nimport type { type } from \"./keywords/keywords.ts\";\nimport type { Type } from \"./type.ts\";\nexport type { arkPrototypes as object } from \"./keywords/constructors.ts\";\nexport type Comparator = \"<\" | \"<=\" | \">\" | \">=\" | \"==\";\nexport type RegexLiteral<source extends string = string> = `/${source}/`;\nexport type DateLiteral<source extends string = string> = `d\"${source}\"` | `d'${source}'`;\nexport type LimitLiteral = number | DateLiteral;\nexport type normalizeLimit<limit> = limit extends DateLiteral<infer source> ? source : limit extends number | string ? limit : never;\nexport type distill<t, side extends distill.Side> = finalizeDistillation<t, _distill<t, side>>;\nexport declare namespace distill {\n    type Side = \"in\" | \"out\" | \"introspectableOut\";\n    type In<t> = distill<t, \"in\">;\n    type Out<t> = distill<t, \"out\">;\n    namespace introspectable {\n        type Out<t> = distill<t, \"introspectableOut\">;\n    }\n}\ntype finalizeDistillation<t, distilled> = equals<t, distilled> extends true ? t : distilled;\ntype _distill<t, side extends distill.Side> = t extends undefined ? t : [t] extends [anyOrNever] ? t : unknown extends t ? unknown : t extends Brand<infer base> ? side extends \"in\" ? base : t : t extends TerminallyInferredObject | Primitive ? t : t extends Function ? t extends (...args: never) => anyOrNever ? t : t extends InferredMorph<infer i, infer o> ? distillIo<i, o, side> : t : t extends Default<infer constraint> ? _distill<constraint, side> : t extends array ? distillArray<t, side> : isSafelyMappable<t> extends true ? distillMappable<t, side> : t;\ntype distillMappable<o, side extends distill.Side> = side extends \"in\" ? show<{\n    [k in keyof o as k extends inferredDefaultKeyOf<o> ? never : k]: _distill<o[k], side>;\n} & {\n    [k in inferredDefaultKeyOf<o>]?: _distill<o[k], side>;\n}> : {\n    [k in keyof o]: _distill<o[k], side>;\n};\ntype distillIo<i, o extends Out, side extends distill.Side> = side extends \"out\" ? _distill<o[\"t\"], side> : side extends \"in\" ? _distill<i, side> : o extends To<infer validatedOut> ? _distill<validatedOut, side> : unknown;\ntype unwrapInput<t> = t extends InferredMorph<infer i> ? t extends anyOrNever ? t : i : t;\ntype inferredDefaultKeyOf<o> = keyof o extends infer k ? k extends keyof o ? unwrapInput<o[k]> extends Default<infer t> ? [\n    t\n] extends [anyOrNever] ? never : k : never : never : never;\ntype distillArray<t extends array, side extends distill.Side> = t[number][] extends t ? alignReadonly<_distill<t[number], side>[], t> : distillNonArraykeys<t, alignReadonly<distillArrayFromPrefix<[...t], side, []>, t>, side>;\ntype alignReadonly<result extends unknown[], original extends array> = original extends unknown[] ? result : Readonly<result>;\ntype distillNonArraykeys<originalArray extends array, distilledArray, side extends distill.Side> = keyof originalArray extends keyof distilledArray ? distilledArray : distilledArray & _distill<{\n    [k in keyof originalArray as k extends keyof distilledArray ? never : k]: originalArray[k];\n}, side>;\ntype distillArrayFromPrefix<t extends array, side extends distill.Side, prefix extends array> = t extends readonly [infer head, ...infer tail] ? distillArrayFromPrefix<tail, side, [\n    side,\n    head\n] extends [\"in\", Default] ? [...prefix, _distill<head, side>?] : [...prefix, _distill<head, side>]> : [...prefix, ...distillArrayFromPostfix<t, side, []>];\ntype distillArrayFromPostfix<t extends array, side extends distill.Side, postfix extends array> = t extends readonly [...infer init, infer last] ? distillArrayFromPostfix<init, side, [_distill<last, side>, ...postfix]> : [...{\n    [i in keyof t]: _distill<t[i], side>;\n}, ...postfix];\ntype BuiltinTerminalObjectKind = Exclude<arkPrototypes.NonDegenerateName, \"Array\" | \"Function\">;\n/** Objects we don't want to expand during inference like Date or Promise */\ntype TerminallyInferredObject = arkPrototypes.instanceOf<BuiltinTerminalObjectKind> | ArkEnv.prototypes;\nexport type inferPredicate<t, predicate> = predicate extends (data: any, ...args: any[]) => data is infer narrowed ? narrowed : t;\nexport type inferNaryPipe<morphs extends readonly Morph[]> = _inferNaryPipe<morphs, unknown>;\ntype _inferNaryPipe<remaining extends readonly unknown[], result> = remaining extends (readonly [infer head extends Morph, ...infer tail extends Morph[]]) ? _inferNaryPipe<tail, inferMorph<result, head>> : result;\nexport type inferNaryIntersection<types extends readonly unknown[]> = number extends types[\"length\"] ? _inferNaryIntersection<unionToTuple<types[number]>, unknown> : _inferNaryIntersection<types, unknown>;\ntype _inferNaryIntersection<remaining extends readonly unknown[], result> = remaining extends readonly [infer head, ...infer tail] ? _inferNaryIntersection<tail, inferIntersection<result, head>> : result;\nexport type inferNaryMerge<types extends readonly unknown[]> = number extends types[\"length\"] ? _inferUnorderedMerge<types> : _inferNaryMerge<types, {}>;\ntype _inferUnorderedMerge<types extends readonly unknown[], optionalKey extends PropertyKey = optionalAtLeastOnceUnionKeyOf<types[number]>, requiredKey extends PropertyKey = Exclude<unionKeyOf<types[number]>, optionalKey>> = show<{\n    [k in requiredKey]: types[number] extends infer v ? v extends unknown ? k extends keyof v ? v[k] : never : never : never;\n} & {\n    [k in optionalKey]?: types[number] extends infer v ? v extends unknown ? k extends keyof v ? v[k] : never : never : never;\n}>;\n/** Coalesce keys that exist and are optional on one or more branches of a union */\ntype optionalAtLeastOnceUnionKeyOf<t> = t extends unknown ? optionalKeyOf<t> : never;\ntype _inferNaryMerge<remaining extends readonly unknown[], result> = remaining extends (readonly [infer head, ...infer tail extends readonly unknown[]]) ? _inferNaryMerge<tail, merge<result, head>> : result;\nexport type inferMorphOut<morph extends Morph> = Exclude<ReturnType<morph>, ArkError | ArkErrors>;\ndeclare const isMorphOutKey: \" isMorphOut\";\nexport interface Out<o = any> {\n    [isMorphOutKey]: true;\n    t: o;\n    introspectable: boolean;\n}\nexport interface To<o = any> extends Out<o> {\n    introspectable: true;\n}\nexport type InferredMorph<i = never, o extends Out = Out> = (In: i) => o;\ndeclare const defaultsToKey: \" defaultsTo\";\nexport type Default<t = unknown, v = unknown> = {\n    [defaultsToKey]: [t, v];\n};\nexport type withDefault<t, v, undistributed = t> = t extends InferredMorph ? addDefaultToMorph<t, v> : Default<Exclude<undistributed, InferredMorph>, v>;\ntype addDefaultToMorph<t extends InferredMorph, v> = [\n    normalizeMorphDistribution<t>\n] extends [InferredMorph<infer i, infer o>] ? (In: Default<i, v>) => o : never;\ntype normalizeMorphDistribution<t, undistributedIn = t extends InferredMorph<infer i> ? i : never, undistributedOut extends Out = t extends InferredMorph<never, infer o> ? [\n    o\n] extends [To<infer unwrappedOut>] ? To<unwrappedOut> : o : never> = (Extract<t, InferredMorph> extends anyOrNever ? never : Extract<t, InferredMorph> extends InferredMorph<infer i, infer o> ? [\n    undistributedOut\n] extends [o] ? (In: undistributedIn) => undistributedOut : [undistributedIn] extends [i] ? (In: undistributedIn) => undistributedOut : t : never) | Exclude<t, InferredMorph> extends infer _ ? _ : never;\nexport type defaultFor<t = unknown> = (Primitive extends t ? Primitive : t extends Primitive ? t : never) | (() => t);\nexport type termOrType<t> = t | Type<t, any>;\nexport type inferIntersection<l, r> = normalizeMorphDistribution<_inferIntersection<l, r, false>>;\nexport type inferMorph<t, morph extends Morph> = morph extends type.cast<infer tMorph> ? inferPipe<t, tMorph> : inferMorphOut<morph> extends infer out ? (In: distill.In<t>) => Out<out> : never;\nexport type inferPipe<l, r> = normalizeMorphDistribution<_inferIntersection<l, r, true>>;\ntype _inferIntersection<l, r, piped extends boolean> = [\n    l & r\n] extends [infer t extends anyOrNever] ? t : l extends InferredMorph<infer lIn, infer lOut> ? r extends InferredMorph<never, infer rOut> ? piped extends true ? (In: lIn) => rOut : never : piped extends true ? (In: lIn) => To<r> : (In: _inferIntersection<lIn, r, false>) => lOut : r extends InferredMorph<infer rIn, infer rOut> ? (In: _inferIntersection<rIn, l, false>) => rOut : [l, r] extends [object, object] ? intersectObjects<l, r, piped> extends infer result ? result : never : l & r;\ninterface MorphableIntersection<piped extends boolean> extends Hkt<[unknown, unknown]> {\n    body: _inferIntersection<this[0], this[1], piped>;\n}\ntype intersectObjects<l, r, piped extends boolean> = l extends array ? r extends array ? intersectArrays<l, r, MorphableIntersection<piped>> : // for an intersection with exactly one array operand like { name: string } & string[],\nl & r : r extends array ? l & r : keyof l & keyof r extends never ? show<l & r> : show<{\n    [k in keyof l]: k extends keyof r ? _inferIntersection<l[k], r[k], piped> : l[k];\n} & {\n    [k in keyof r]: k extends keyof l ? _inferIntersection<l[k], r[k], piped> : r[k];\n}>;\n",
  "arktype/index.d.ts": "export { ArkError, ArkErrors, Traversal, TraversalError, type ArkSchemaConfig, type ArkSchemaScopeConfig, type JsonSchema } from \"@ark/schema\";\nexport { Hkt, inferred, ParseError } from \"@ark/util\";\nexport { regex } from \"arkregex\";\nexport type { distill, Out } from \"./attributes.ts\";\nexport * from \"./config.ts\";\nexport { Generic } from \"./generic.ts\";\nexport { ark, declare, define, fn, generic, keywords, match, type, type Ark } from \"./keywords/keywords.ts\";\nexport { Module, type BoundModule, type Submodule } from \"./module.ts\";\nexport type { inferDefinition, validateDefinition } from \"./parser/definition.ts\";\nexport { scope, type bindThis, type Scope } from \"./scope.ts\";\nexport { Type } from \"./type.ts\";\nexport type { BaseType } from \"./variants/base.ts\";\n",
  "@ark/util/index.d.ts": "export * from \"./arrays.ts\";\nexport * from \"./clone.ts\";\nexport * from \"./describe.ts\";\nexport * from \"./domain.ts\";\nexport * from \"./errors.ts\";\nexport * from \"./flatMorph.ts\";\nexport * from \"./functions.ts\";\nexport * from \"./generics.ts\";\nexport * from \"./hkt.ts\";\nexport * from \"./intersections.ts\";\nexport * from \"./isomorphic.ts\";\nexport * from \"./keys.ts\";\nexport * from \"./lazily.ts\";\nexport * from \"./numbers.ts\";\nexport * from \"./objectKinds.ts\";\nexport * from \"./path.ts\";\nexport * from \"./primitive.ts\";\nexport * from \"./records.ts\";\nexport * from \"./registry.ts\";\nexport * from \"./scanner.ts\";\nexport * from \"./serialize.ts\";\nexport * from \"./strings.ts\";\nexport * from \"./traits.ts\";\nexport * from \"./unionToTuple.ts\";\n",
  "@ark/schema/index.d.ts": "export * from \"./config.ts\";\nexport * from \"./constraint.ts\";\nexport * from \"./generic.ts\";\nexport * from \"./intrinsic.ts\";\nexport * from \"./kinds.ts\";\nexport * from \"./module.ts\";\nexport * from \"./node.ts\";\nexport * from \"./parse.ts\";\nexport * from \"./predicate.ts\";\nexport * from \"./refinements/after.ts\";\nexport * from \"./refinements/before.ts\";\nexport * from \"./refinements/divisor.ts\";\nexport * from \"./refinements/exactLength.ts\";\nexport * from \"./refinements/kinds.ts\";\nexport * from \"./refinements/max.ts\";\nexport * from \"./refinements/maxLength.ts\";\nexport * from \"./refinements/min.ts\";\nexport * from \"./refinements/minLength.ts\";\nexport * from \"./refinements/pattern.ts\";\nexport * from \"./refinements/range.ts\";\nexport * from \"./roots/domain.ts\";\nexport * from \"./roots/intersection.ts\";\nexport * from \"./roots/morph.ts\";\nexport * from \"./roots/proto.ts\";\nexport * from \"./roots/root.ts\";\nexport * from \"./roots/union.ts\";\nexport * from \"./roots/unit.ts\";\nexport * from \"./scope.ts\";\nexport * from \"./shared/compile.ts\";\nexport * from \"./shared/declare.ts\";\nexport * from \"./shared/disjoint.ts\";\nexport * from \"./shared/errors.ts\";\nexport * from \"./shared/implement.ts\";\nexport * from \"./shared/intersections.ts\";\nexport * from \"./shared/jsonSchema.ts\";\nexport * from \"./shared/registry.ts\";\nexport * from \"./shared/standardSchema.ts\";\nexport * from \"./shared/toJsonSchema.ts\";\nexport * from \"./shared/traversal.ts\";\nexport * from \"./shared/utils.ts\";\nexport * from \"./structure/index.ts\";\nexport * from \"./structure/optional.ts\";\nexport * from \"./structure/prop.ts\";\nexport * from \"./structure/required.ts\";\nexport * from \"./structure/sequence.ts\";\nexport * from \"./structure/structure.ts\";\nexport { ParseError } from \"@ark/util\";\n",
  "arkregex/index.d.ts": "export { regex, type Regex } from \"./regex.ts\";\n"
}